---
layout: post
lang: es
title: Explotando un SSTI en LiquidJS para leer archivos del servidor
date: 2021/10/26
tags: web bugbounties
permalink: /es/posts/liquidjs-ssti-to-arbitrary-file-read
header:
  teaser: posts/2021-10-26/poc_screenshot.jpeg
---
{% raw %}Hola a todos! Llevaba unos meses pensando en crear mi propio blog de hacking, donde compartir mi proceso de aprendizaje y mis experiencias como principiante y, sobre todo, contribuir a la comunidad. Al final he decidido hacerlo y he pensado que la mejor forma de empezar sería escribiendo sobre mi primera recompensa en un programa de bug bounties, que gané hace un par de meses. Como la vulnerabilidad que encontré no ha sido revelada públicamente, no podŕe dar tanta información como me gustaría, pero espero que guste de todas formas :)

Este verano, decidí probar suerte con las bug bounties, ya que estaba empezando a ganar cierta experiencia con respecto al hacking web en CTFs y demás. Me pasé unos cuantos días ojeando programas de bug bounty públicos, hasta que encontré uno o dos que eran asequibles para mi. Ofrecían unas cuantas funcionalidades interesantes (al menos algo más que una tienda online estándar), no pagaban recompensas muy altas, así que no atraerían la atención de otros bug hunters con más experiencia, y no habían recibido un reporte válido en los últimos 9 meses. De esta forma, abrí Burp y empecé a echar un vistazo a las aplicaciones de uno de estos programas.

Después de un par de horas familiarizándome con las distintas páginas web y viendo cuál era el flujo de trabajo de un usuario normal, me encontré con una funcionalidad muy interesante. Una de las aplicaciones tenía un área para administradores a la uno podía acceder registrándose como administrador de su propia compañía, creada previamente. En ella, se podían gestionar clientes, servicios prestados, etc. Una de las funcionalidades de este panel de administrador era crear y editar plantillas de correo electrónico, de forma que se pudieran utilizar para enviar correos personalizados a un conjunto de clientes a la vez. Cuando ví esto, me acordé de <a href="https://hackerone.com/reports/125980/">un informe de Uber en HackerOne</a> que había leído recientemente, donde se encontraba un SSTI en un motor de renderizado de plantillas de correo electrónico muy similar.

Un SSTI ("Server Side Template Injection") es una vulnerabilidad de los motores de plantillas ("template engines") en la que un atacante puede inyectar sintaxis nativa del lenguaje de plantillas en el texto renderizado, que se ejecutará en el lado del servidor. Dependiendo del motor de plantillas la gravedad puede variar, pudiendo incluso llegar a RCE.  

Cuando abrí el editor de plantillas de correo electrónico, lo primero que vi fue que el valor predeterminado para el encabezado era "{{account.logo}}", que tenía bastante pinta de ser sintaxis de algún lenguaje de plantillas: 

<img src="/assets/images/posts/2021-10-26/account_logo.png" style="width: 40em;">

Además, el editor de plantillas de correo tenía un botón para poder testear la plantilla antes de guardarla, enviando una versión preliminar al correo del administrador. De esta manera, cualquier contenido renderizado por la plantilla podría ser directamente enviado al administrador para verlo (yo). Empecé introduciendo el valor "{{account}}", que al renderizarse me envió un correo con el contenido "[object Object]". Esto es la representación "cruda" de un objeto de JavaScript que no está pensado para ser representado como un string. Al ver esto, me emocioné bastante, ya que significaba que el valor que había introducido se había renderizado correctamente y había producido un valor que los desarrolladores no habían tenido en cuenta, por lo que era muy posible que hubiese un SSTI!

Sin embargo, fue precisamente por esta emoción inicial que no pensé con claridad, así que cometí el error de asumir la tecnología concreta que utilizaba el motor de plantillas sin comprobarlo explícitamente. Como ya me había enfrentado en algún CTF a SSTIs en Nunjucks (un motor de plantillas muy común de JavaScript) y la sintaxis era la misma, asumí directamente que este era el que se estaba utilizando aquí. Lo tenía tan claro que ni lo pensé dos veces. Fui directo a <a href="http://disse.cting.org/2016/08/02/2016-08-02-sandbox-break-out-nunjucks-template-engine">un artículo que había leído recientemente sobre el tema</a> y empecé a intentar conseguir RCE.

Adapté el payload del artículo a este caso e introduje lo siguiente:

<code class="language-javascript">{{account.constructor(function(){return 123})()}}</code>

Sin embargo, no recibí ningún correo. Probé también con el siguiente payload:

<code class="language-javascript">{account.constructor.constructor('return 123')()}}</code> 

Pero tampoco, ningún correo. Tras probar un poco más, me di cuenta de que el típico payload de SSTI "{{7*7}}" tampoco funcionaba. Sin embargo, al enviar los siguientes payloads:

<code class="language-javascript">{{account.constructor}}
{{account.constructor.constructor}}</code>

Recibía los siguientes correos respectivamente:

<code class="language-javascript">function Object() { [native code] }
function Function() { [native code] }</code>

No le veía el sentido. ¿Podía llegar a objetos y funciones de JavaScript pero no podía ejecutarlas?¿Tampoco podía ejecutar operaciones aritméticas? Lo dejé ahí mismo y me tomé un pequeño descanso.

<img src="/assets/images/posts/2021-10-26/tries_screenshot.png" style="width: 35em;">

Tras un par de días y como ya adelanté anteriormente, de repente me di cuenta de que no me había cerciorado de que el motor de plantillas que estaba utilizando la aplicación fuese Nunjucks, ni siquiera si utilizaba NodeJS. Busqué los motores de plantillas más comunes que utilizasen los tags "{{ }}" y empecé a probar. Sin embargo, seguía bastante nervioso y no pensaba con claridad. No investigué muy a fondo y ninguno de los motores de plantilla que había encontrado coincidían. Probé Mustache, Handlebars, Atpl... Pero nada. Me estaba frustrando mucho y, entonces, supe que debía tomarme un descanso más largo y apartarme del tema un tiempo. Aquí noté de lleno que no estaba para nada acostumbrado al bug bounty y que esto podía ser mucho más frustrante que cualquier CTF en el que hubiera participado nunca.

A todo esto, el verano terminó y comenzó la Universidad, así que sabía que a partir de entonces iba a tener menos tiempo libre. Además, todavía tenía la espina clavada al no haber conseguido encontrar un bug explotable en esta aplicación web. Así que, un día comencé a leerme las notas que había ido tomando a lo largo de todo el proceso, repitiendo todo y poniendo atención en cada detalle. Cuando llegué al punto donde supuestamente "había investigado  sobre los motores de plantilla de NodeJS", me di cuenta de la investigación tan pobre y poco minuciosa que hice, así que decidí repetirla. Al menos con el fin de entender qué estaba pasando con este motor de plantillas concreto.

Esta vez, investigué de forma más amplia y ordenada, probando cada opción posible de entre todos los motores de plantillas que pude encontrar por ahí. Al final, descarté Nunjuck al probar toda la sintaxis que ofrecía, e hice lo mismo con otros motores de plantillas de NodeJS. Al final, encontré que el motor que estaba utilizando era <a href="https://liquidjs.com/">LiquidJS</a>, un motor muy similar al <a href="https://github.com/Shopify/liquid">Liquid</a> que utiliza Shopify o Github pages. De esta forma, vi que LiquidJS no permitía ejecutar código de la misma forma que otros motores. Encima, no pude encontrar ningún ejemplo en Internet en el que se explotase un SSTI en LiquidJS, así que tuve que investigar más a fondo todavía.

Leyendo la documentación de LiquidJS, encontré un tag descontinuado "include", que permitía renderizar plantillas predefinidas. Sin embargo, investigando un poco más pude ver que un atacante también podría incluir cualquier otro archivo del servidor, aunque no fuera realmente una plantilla, permitiendo acceder a todo el sistema de archivos del servidor (de hecho, en el momento de escribir este post encontré esta <a href="https://github.com/harttle/liquidjs/issues/131">issue de Github</a> en la que se describe esta problemática). Al final, simplemente tuve que introducir el siguiente payload para recibir un correo con el contenido del fichero "/etc/passwd":

<code class="language-javascript">{% include '/etc/passwd' %}</code>

<img src="/assets/images/posts/2021-10-26/poc_screenshot.jpeg" style="width: 35em;">

No fui capaz de conseguir RCE, sin embargo, obtuve una Lectura Arbitraria de Archivos y una recompensa de 1500$, que no está nada mal para ser mi primera vez. Gracias por leerlo y espero que os haya gustado :)
{% endraw %}
